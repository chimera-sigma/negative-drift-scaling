<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover"
  />
  <title>Anti-Dissipative Dynamics in Neural Network Optimization — Demo</title>
  <meta name="color-scheme" content="dark light" />
  <style>
    :root {
      /* Palette */
      --bg: #0f172a;             /* slate-900 */
      --bg-grad-a: #0f172a;
      --bg-grad-b: #1e293b;      /* slate-800 */
      --panel: color-mix(in oklab, white 8%, transparent);
      --panel-border: color-mix(in oklab, white 12%, transparent);
      --text: #e5e7eb;           /* zinc-200 */
      --muted: #94a3b8;          /* slate-400 */
      --accent: #a7f3d0;         /* teal-200 */
      --accent-strong: #34d399;  /* emerald-400 */
      --brand: #60a5fa;          /* blue-400 */
      --good: #22c55e;           /* green-500 */
      --warn: #f59e0b;           /* amber-500 */
      --bad:  #ef4444;           /* red-500 */

      /* Series colors */
      --sgd: #ef4444;        /* red-500 */
      --adam: #14b8a6;       /* teal-500 */
      --symp: #84cc16;       /* lime-500 */

      --radius-lg: 16px;
      --radius-md: 12px;
      --radius-sm: 10px;

      --shadow-lg: 0 10px 30px rgba(0,0,0,.35);
      --shadow-md: 0 6px 18px rgba(0,0,0,.28);
      --shadow-sm: 0 4px 10px rgba(0,0,0,.18);
    }

    @media (prefers-color-scheme: light) {
      :root {
        --bg: #f8fafc;
        --bg-grad-a: #f8fafc;
        --bg-grad-b: #eef2ff;
        --panel: #ffffffcc;
        --panel-border: #e5e7eb;
        --text: #0f172a;
        --muted: #475569;
        --accent: #059669;
        --accent-strong: #047857;
        --brand: #2563eb;
        --good: #16a34a;
        --warn: #d97706;
        --bad:  #dc2626;
        --shadow-lg: 0 10px 30px rgba(2,6,23,.12);
        --shadow-md: 0 6px 18px rgba(2,6,23,.10);
        --shadow-sm: 0 4px 10px rgba(2,6,23,.08);
      }
    }

    /* Global layout & typography */
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
      color: var(--text);
      background:
        radial-gradient(1200px 800px at 15% -10%, color-mix(in oklab, var(--brand) 20%, transparent), transparent 60%),
        linear-gradient(180deg, var(--bg-grad-a), var(--bg-grad-b));
      line-height: 1.45;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      padding: clamp(16px, 2vw, 28px);
    }

    header.page {
      text-align: center;
      margin-bottom: 20px;
    }
    header.page h1 {
      margin: 0 0 6px 0;
      font-size: clamp(1.6rem, 1.2rem + 2vw, 2.4rem);
      letter-spacing: .2px;
      font-weight: 800;
    }
    header.page p {
      margin: 0 auto;
      max-width: 70ch;
      color: var(--muted);
      font-size: clamp(.95rem, .9rem + .25vw, 1.05rem);
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    .panel {
      background: var(--panel);
      backdrop-filter: blur(10px) saturate(120%);
      -webkit-backdrop-filter: blur(10px) saturate(120%);
      border: 1px solid var(--panel-border);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-lg);
      padding: clamp(16px, 2.4vw, 28px);
    }

    /* Controls */
    .controls {
      display: grid;
      grid-template-columns: 1fr;
      gap: 14px;
      align-items: center;
      justify-items: center;
      margin-bottom: 20px;
    }
    .control-row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: center;
      align-items: stretch;
    }

    button {
      --btn-bg: color-mix(in oklab, var(--brand) 18%, white 0%);
      --btn-bg2: color-mix(in oklab, var(--brand) 10%, white 0%);
      --btn-text: #0b1020;
      appearance: none;
      border: 1px solid color-mix(in oklab, var(--brand) 45%, transparent);
      background: linear-gradient(180deg, var(--btn-bg), var(--btn-bg2));
      color: #0b1020;
      padding: 10px 16px;
      font-weight: 700;
      border-radius: 999px;
      cursor: pointer;
      box-shadow: var(--shadow-sm);
      transition: transform .12s ease, box-shadow .12s ease, background .25s ease, border-color .25s ease;
      font-size: 0.975rem;
    }
    button:hover { transform: translateY(-1px); box-shadow: var(--shadow-md); }
    button:active { transform: translateY(0); box-shadow: var(--shadow-sm); }
    button:disabled { opacity: .55; cursor: not-allowed; }
    button:focus-visible {
      outline: 3px solid color-mix(in oklab, var(--brand) 60%, white 0%);
      outline-offset: 2px;
    }

    .slider {
      display: grid;
      grid-template-columns: auto min(280px, 65vw) auto;
      align-items: center;
      gap: 10px;
      background: color-mix(in oklab, var(--brand) 6%, transparent);
      border: 1px solid color-mix(in oklab, var(--brand) 18%, transparent);
      padding: 10px 12px;
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-sm);
    }
    .slider label {
      font-size: .9rem;
      color: var(--muted);
      white-space: nowrap;
    }
    .slider output {
      min-width: 4.5ch;
      text-align: right;
      font-variant-numeric: tabular-nums;
      font-weight: 800;
      color: var(--accent);
    }

    /* Cross-browser range styling */
    input[type="range"] {
      width: 100%;
      background: transparent;
    }
    input[type="range"]::-webkit-slider-runnable-track {
      height: 6px;
      background: color-mix(in oklab, var(--brand) 20%, transparent);
      border-radius: 999px;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px; height: 18px; border-radius: 50%;
      margin-top: -6px;
      background: var(--accent-strong);
      border: 2px solid #0b1020;
      box-shadow: 0 0 0 3px color-mix(in oklab, var(--accent-strong) 35%, transparent);
      transition: box-shadow .2s ease;
    }
    input[type="range"]:focus-visible::-webkit-slider-thumb {
      box-shadow: 0 0 0 5px color-mix(in oklab, var(--accent-strong) 55%, transparent);
    }
    input[type="range"]::-moz-range-track {
      height: 6px;
      background: color-mix(in oklab, var(--brand) 20%, transparent);
      border-radius: 999px;
    }
    input[type="range"]::-moz-range-thumb {
      width: 18px; height: 18px; border-radius: 50%;
      background: var(--accent-strong);
      border: 2px solid #0b1020;
      box-shadow: 0 0 0 3px color-mix(in oklab, var(--accent-strong) 35%, transparent);
      transition: box-shadow .2s ease;
    }

    /* Plot grid */
    .canvas-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: clamp(12px, 1.8vw, 20px);
      margin-top: 12px;
    }
    @media (max-width: 920px) {
      .canvas-grid { grid-template-columns: 1fr; }
    }

    .canvas-card {
      background: color-mix(in oklab, white 5%, transparent);
      border: 1px solid color-mix(in oklab, white 12%, transparent);
      border-radius: var(--radius-md);
      padding: 12px;
      position: relative;
      box-shadow: var(--shadow-sm);
    }
    .canvas-card.canvas-wide {
      grid-column: 1 / -1;
    }
    .canvas-card figcaption {
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-weight: 700;
      font-size: .98rem;
      color: var(--text);
      margin-bottom: 8px;
    }
    .hint {
      color: var(--muted);
      font-weight: 500;
      font-size: .85rem;
    }

    canvas.plot {
      display: block;
      width: 100%;
      height: 220px; /* CSS pixel height; JS maps to device pixels */
      border-radius: var(--radius-sm);
      background: #fff;
    }

    .badge {
      position: absolute;
      top: 10px; right: 12px;
      background: color-mix(in oklab, var(--good) 80%, white 0%);
      color: #0b1020;
      padding: 6px 10px;
      font-size: .75rem;
      border-radius: 999px;
      font-weight: 900;
      letter-spacing: .2px;
      box-shadow: var(--shadow-sm);
      opacity: 0;
      transform: translateY(-4px);
      transition: opacity .25s ease, transform .25s ease;
    }
    .badge.active {
      opacity: 1;
      transform: translateY(0);
    }

    .legend {
      display: flex;
      gap: 16px;
      align-items: center;
      margin: 10px 2px 2px;
      color: var(--muted);
      font-size: .9rem;
    }
    .key { display: inline-flex; align-items: center; gap: 8px; }
    .dot {
      width: 10px; height: 10px;
      border-radius: 50%;
      display: inline-block;
    }
    .dot.sgd { background: var(--sgd); }
    .dot.adam { background: var(--adam); }
    .dot.symp { background: var(--symp); }

    /* Stats */
    .stats {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 14px;
      margin-top: 12px;
    }
    @media (max-width: 720px) {
      .stats { grid-template-columns: 1fr; }
    }
    .stat-card {
      border: 1px solid color-mix(in oklab, var(--brand) 15%, var(--panel-border));
      background: color-mix(in oklab, white 5%, transparent);
      border-radius: var(--radius-md);
      padding: 12px 14px;
      text-align: center;
      box-shadow: var(--shadow-sm);
      transition: border-color .25s ease, box-shadow .25s ease;
    }
    .stat-card.negative {
      border-color: color-mix(in oklab, var(--good) 55%, var(--panel-border));
      box-shadow: 0 0 0 4px color-mix(in oklab, var(--good) 18%, transparent), var(--shadow-md);
    }
    @media (prefers-reduced-motion: no-preference) {
      .stat-card.negative { animation: subtlePulse 2.4s ease-in-out infinite; }
      @keyframes subtlePulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.015); }
      }
    }

    .stat-label { font-size: .85rem; color: var(--muted); margin-bottom: 4px; }
    .stat-value { font-size: 1.6rem; font-weight: 800; letter-spacing: .2px; }
    .stat-ci { font-size: .8rem; color: var(--muted); margin-top: 4px; }
    .sgd-value { color: var(--sgd); }
    .adam-value { color: var(--adam); }
    .symp-value { color: var(--symp); }

    /* Info & status */
    .status {
      text-align: center;
      color: var(--muted);
      font-style: italic;
      margin: 8px 0 6px;
    }
    .info {
      background: color-mix(in oklab, var(--good) 8%, transparent);
      border: 1px solid color-mix(in oklab, var(--good) 30%, transparent);
      border-left: 4px solid var(--good);
      border-radius: var(--radius-md);
      padding: 14px 16px;
      margin-top: 16px;
      box-shadow: var(--shadow-sm);
    }
    .info h3 {
      margin: 0 0 6px 0;
      font-size: 1.05rem;
      color: var(--good);
    }
    .info p { margin: 6px 0; }

    /* Tooltips (no JS) */
    .tooltip {
      position: relative;
      cursor: help;
      text-decoration: underline dotted 1px;
      text-underline-offset: 3px;
    }
    .tooltip:hover .tt {
      opacity: 1; transform: translate(-50%, -4px);
      pointer-events: auto;
    }
    .tt {
      pointer-events: none;
      position: absolute;
      left: 50%; bottom: calc(100% + 8px);
      transform: translate(-50%, 0);
      background: rgba(0,0,0,.85);
      color: #fff;
      border-radius: 8px;
      padding: 8px 10px;
      width: min(58ch, 260px);
      font-size: .82rem;
      line-height: 1.2;
      opacity: 0;
      transition: opacity .2s ease, transform .2s ease;
      z-index: 5;
      box-shadow: 0 6px 18px rgba(0,0,0,.35);
    }

    /* Small niceties */
    code.k { background: color-mix(in oklab, var(--brand) 12%, transparent); padding: 1px 6px; border-radius: 6px; }
    .sr-only {
      position: absolute !important;
      width: 1px; height: 1px;
      padding: 0; margin: -1px;
      overflow: hidden; clip: rect(0, 0, 1px, 1px);
      white-space: nowrap; border: 0;
    }
  </style>
</head>
<body>
  <header class="page">
    <h1>Anti-Dissipative Dynamics in Neural Network Optimization</h1>
    <p>Interactive demo of negative drift scaling across step-size regimes</p>
  </header>

  <main class="container">
    <section class="panel" aria-labelledby="panel-title">
      <h2 class="sr-only" id="panel-title">Interactive Demo</h2>

      <!-- Controls -->
      <div class="controls" role="group" aria-label="Simulation controls">
        <div class="control-row">
          <button id="startBtn" type="button" aria-pressed="false" title="Start or pause the live simulation">▶ Start</button>
          <button id="resetBtn" type="button" title="Reset parameters and clear plots">↻ Reset</button>
          <button id="sweepBtn" type="button" 
                  aria-label="Run a reproducible drift-slope measurement sweep"
                  title="Run a reproducible drift-slope measurement sweep">⟲ Measure Slopes</button>
        </div>

        <div class="control-row" role="group" aria-label="Parameter sliders">
          <div class="slider" id="dtSliderBox">
            <label for="stepSize">Step Size (<span class="tooltip">dt<span class="tt">Integration step for the live animation. "Measure Slopes" uses dt ∈ [0.002, 0.0035]. The slider allows up to 0.035 for exploration.</span></span>)</label>
            <input id="stepSize" type="range" min="2" max="35" step="1" value="3" aria-valuemin="0.002" aria-valuemax="0.035" aria-valuenow="0.003" aria-label="Step size">
            <output id="stepValue" for="stepSize">0.003</output>
          </div>

          <div class="slider" id="noiseSliderBox">
            <label for="noise">Noise Level (σ)</label>
            <input id="noise" type="range" min="0" max="50" step="1" value="10" aria-valuemin="0" aria-valuemax="0.50" aria-valuenow="0.10" aria-label="Noise level">
            <output id="noiseValue" for="noise">0.10</output>
          </div>
        </div>
      </div>

      <p id="measureStatus" class="status" role="status" aria-live="polite">Click "Measure Slopes" to compute drift scaling across dt ∈ [0.002, 0.0035].</p>

      <!-- Plots -->
      <div class="canvas-grid">
        <figure class="canvas-card">
          <figcaption>
            <span>SGD (Euler) — Energy vs. Time</span>
            <span class="hint">V(t)</span>
          </figcaption>
          <canvas id="sgdCanvas" class="plot" data-height="220"></canvas>
        </figure>

        <figure class="canvas-card">
          <figcaption>
            <span>AdamW (toy) — Energy vs. Time</span>
            <span class="hint">V(t)</span>
          </figcaption>
          <canvas id="adamCanvas" class="plot" data-height="220"></canvas>
        </figure>

        <figure class="canvas-card canvas-wide">
          <figcaption>
            <span>Symplectic Leapfrog — Total Energy vs. Time</span>
            <span class="hint">H(t) = K + V</span>
          </figcaption>
          <canvas id="sympCanvas" class="plot" data-height="220" aria-describedby="sympNote"></canvas>
          <div id="magicIndicator" class="badge" aria-hidden="true">NEGATIVE SLOPE</div>
          <p id="sympNote" class="sr-only">Symplectic method shows characteristic energy conservation. In the canonical band, measured drift scaling can become negative.</p>
        </figure>
      </div>

      <div class="legend" aria-hidden="true">
        <span class="key"><span class="dot sgd"></span> SGD</span>
        <span class="key"><span class="dot adam"></span> AdamW</span>
        <span class="key"><span class="dot symp"></span> Symplectic</span>
      </div>

      <!-- Stats -->
      <div class="stats">
        <div class="stat-card" id="sgdCard" role="group" aria-label="SGD drift statistics">
          <div class="stat-label">SGD Drift Slope (log–log)</div>
          <div class="stat-value sgd-value" id="sgdSlope">—</div>
          <div class="stat-ci" id="sgdCI" aria-label="95% CI"></div>
        </div>

        <div class="stat-card" id="adamCard" role="group" aria-label="AdamW drift statistics">
          <div class="stat-label">AdamW Drift Slope (log–log)</div>
          <div class="stat-value adam-value" id="adamSlope">—</div>
          <div class="stat-ci" id="adamCI" aria-label="95% CI"></div>
        </div>

        <div class="stat-card" id="sympCard" role="group" aria-label="Symplectic drift statistics">
          <div class="stat-label">Symplectic Drift Slope (log–log)</div>
          <div class="stat-value symp-value" id="sympSlope">—</div>
          <div class="stat-ci" id="sympCI" aria-label="95% CI"></div>
        </div>
      </div>

      <!-- Updated info block -->
      <div class="info">
        <h3>What You're Seeing</h3>
        <p><strong>The discovery.</strong> Click <em>Measure Slopes</em> to estimate drift scaling across <code class="k">dt ∈ [0.002, 0.0035]</code>. With mass preconditioning, symplectic leapfrog can show a negative slope in this band (larger steps, smaller drift).</p>
        <p><strong>Units.</strong> This is a toy 2-D system for illustration; energy units here are arbitrary and act as a proxy for the paper's tail-median |ΔH| in nats.</p>
        <p><strong>The physics.</strong> In this band, <strong>larger</strong> integration steps actually yield <strong>better</strong> energy conservation (drift slope &lt; 0). That's the inverse of first-order methods (SGD, AdamW), which typically show a positive slope.</p>
        <p><strong>The experiment.</strong> Adjust σ and re-measure. The negative trend persists across noise levels—evidence that this is a robust property of the dynamics, not a numerical illusion.</p>
      </div>
    </section>
  </main>

  <noscript>
    <p style="max-width:60ch;margin:12px auto;text-align:center;color:#ef4444;font-weight:700">
      JavaScript is required for this demo. Please enable it to run simulations and measurements.
    </p>
  </noscript>

  <script>
    'use strict';

    // --- Utilities -----------------------------------------------------------

    function mulberry32(a) {
      return function() {
        let t = a += 0x6D2B79F5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }
    function hashString(s) {
      let h = 0;
      for (let i = 0; i < s.length; i++) h = (h * 31 + s.charCodeAt(i)) | 0;
      return h >>> 0;
    }
    const $ = (id) => document.getElementById(id);

    // Hi-DPI canvas sizing: keep canvas CSS pixels stable, map to device pixels
    function sizeCanvasForDisplay(canvas) {
      const ratio = Math.max(1, window.devicePixelRatio || 1);
      const cssWidth = canvas.clientWidth;
      const cssHeight = parseFloat(getComputedStyle(canvas).height) || canvas.height || 200;
      const needResize = canvas.width !== Math.floor(cssWidth * ratio) ||
                         canvas.height !== Math.floor(cssHeight * ratio);
      if (needResize) {
        canvas.width = Math.max(1, Math.floor(cssWidth * ratio));
        canvas.height = Math.max(1, Math.floor(cssHeight * ratio));
        const ctx = canvas.getContext('2d');
        // Map 1 canvas unit to 1 CSS pixel
        ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
      }
      return { width: cssWidth, height: cssHeight };
    }

    function drawEnergyPlot(ctx, history, color, w, h) {
      ctx.clearRect(0, 0, w, h);

      // Grid
      ctx.save();
      ctx.lineWidth = 1;
      ctx.strokeStyle = 'rgba(120,120,120,0.25)';
      const rows = 4;
      for (let i = 0; i <= rows; i++) {
        const y = (i / rows) * h;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
      }
      ctx.restore();

      if (!history || history.length < 2) return;

      const minE = Math.min(...history);
      const maxE = Math.max(...history);
      const range = Math.max(1e-12, maxE - minE);

      ctx.beginPath();
      ctx.lineWidth = 2;
      ctx.strokeStyle = color;

      for (let i = 0; i < history.length; i++) {
        const x = (i / (history.length - 1)) * w;
        const y = h - ((history[i] - minE) / range) * h * 0.82 - h * 0.09;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
    }

    // --- Optimizer model -----------------------------------------------------

    class Optimizer {
      constructor(type, rng = Math.random) {
        this.type = type;
        this.rng = rng;

        // State
        this.x = 1.0;
        this.y = 0.5;
        this.px = 0.0;
        this.py = 0.0;

        // Adam state
        this.mx = 0; this.my = 0;
        this.vx = 0; this.vy = 0;
        this.t = 0;

        // Mass preconditioning (sweet spot for negative slope)
        this.massInv = 0.35;

        // Energy tracking
        this.energyHistory = [];
        this.maxHistory = 220;
        this.initialEnergy = this.getEnergy();
      }

      potential(x, y) {
        // V(x,y) = 0.5(x^2 + y^2) + 0.3 cos(3x) + 0.2 sin(2y)
        return 0.5 * (x * x + y * y) + 0.3 * Math.cos(3 * x) + 0.2 * Math.sin(2 * y);
      }
      gradient(x, y) {
        // d/dx: x - 0.9 sin(3x) ; d/dy: y + 0.4 cos(2y)
        return { x: x - 0.9 * Math.sin(3 * x), y: y + 0.4 * Math.cos(2 * y) };
      }
      getEnergy() {
        const V = this.potential(this.x, this.y);
        if (this.type === 'symplectic') {
          const K = 0.5 * (this.px * this.px + this.py * this.py) * this.massInv;
          return V + K;
        }
        return V; // first-order: track potential as "energy" proxy
      }

      update(dt, noise) {
        const grad = this.gradient(this.x, this.y);

        // Consistent gradient noise model: one draw per step (scaled ~ sqrt(dt))
        const nscale = Math.sqrt(Math.max(1e-8, dt));
        const rand = () => this.rng() * 2 - 1;
        const nx = rand() * noise * nscale;
        const ny = rand() * noise * nscale;
        const gx = grad.x + nx;
        const gy = grad.y + ny;

        if (this.type === 'sgd') {
          // Euler
          this.x -= dt * gx;
          this.y -= dt * gy;

        } else if (this.type === 'adam') {
          // AdamW (toy)
          this.t++;
          const beta1 = 0.9, beta2 = 0.999, eps = 1e-8, wd = 1e-4;

          this.mx = beta1 * this.mx + (1 - beta1) * gx;
          this.my = beta1 * this.my + (1 - beta1) * gy;
          this.vx = beta2 * this.vx + (1 - beta2) * gx * gx;
          this.vy = beta2 * this.vy + (1 - beta2) * gy * gy;

          const mhatx = this.mx / (1 - Math.pow(beta1, this.t));
          const mhaty = this.my / (1 - Math.pow(beta1, this.t));
          const vhatx = this.vx / (1 - Math.pow(beta2, this.t));
          const vhaty = this.vy / (1 - Math.pow(beta2, this.t));

          this.x = (1 - dt * wd) * this.x - dt * mhatx / (Math.sqrt(vhatx) + eps);
          this.y = (1 - dt * wd) * this.y - dt * mhaty / (Math.sqrt(vhaty) + eps);

        } else if (this.type === 'symplectic') {
          // Leapfrog with light damping & mass preconditioning
          const gamma = 0.01;

          // half-step momentum (damped)
          this.px *= Math.exp(-gamma * dt / 2);
          this.py *= Math.exp(-gamma * dt / 2);
          this.px -= (dt / 2) * gx;
          this.py -= (dt / 2) * gy;

          // position update (mass preconditioning)
          this.x += dt * this.massInv * this.px;
          this.y += dt * this.massInv * this.py;

          // recompute gradient at new position; reuse SAME noise sample
          const g2 = this.gradient(this.x, this.y);
          this.px -= (dt / 2) * (g2.x + nx);
          this.py -= (dt / 2) * (g2.y + ny);

          this.px *= Math.exp(-gamma * dt / 2);
          this.py *= Math.exp(-gamma * dt / 2);

          // Relative energy cap (avoid runaways in viz)
          const capMult = 2.0;
          const cap = capMult * (this.initialEnergy || 1.0);
          const E = this.getEnergy();
          if (E > cap) {
            const V = this.potential(this.x, this.y);
            const K = Math.max(1e-12, E - V);
            const targetK = Math.max(1e-12, cap - V);
            const scale = Math.sqrt(targetK / K);
            this.px *= scale; this.py *= scale;
          }
        }

        // Record energy
        const energy = this.getEnergy();
        this.energyHistory.push(energy);
        if (this.energyHistory.length > this.maxHistory) this.energyHistory.shift();
      }
    }

    // --- Measurement helpers -------------------------------------------------

    function medianAbsChange(tail) {
      const changes = [];
      for (let i = 1; i < tail.length; i++) changes.push(Math.abs(tail[i] - tail[i - 1]));
      changes.sort((a, b) => a - b);
      return changes.length ? changes[Math.floor(changes.length / 2)] : 0;
    }

    function measureDrift(method, dt, noise, steps = 250) {
      // Stable per (method, dt)
      const seed = (Math.floor(dt * 1e6) ^ hashString(method)) >>> 0;
      const rng = mulberry32(seed);
      const o = new Optimizer(method, rng);
      for (let i = 0; i < steps; i++) o.update(dt, noise);
      const tailStart = Math.floor(o.energyHistory.length * 0.8);
      const tail = o.energyHistory.slice(tailStart);
      return medianAbsChange(tail);
    }

    function olsSlopeLog10(xs, ys) {
      const lx = xs.map(Math.log10);
      const ly = ys.map(y => Math.log10(Math.max(1e-12, y)));
      const n = lx.length;

      const xm = lx.reduce((a, b) => a + b, 0) / n;
      const ym = ly.reduce((a, b) => a + b, 0) / n;

      let Sxx = 0, Sxy = 0;
      for (let i = 0; i < n; i++) { const dx = lx[i] - xm; Sxx += dx * dx; Sxy += dx * (ly[i] - ym); }
      const slope = Sxx ? Sxy / Sxx : 0;
      const b = ym - slope * xm;

      let RSS = 0;
      for (let i = 0; i < n; i++) {
        const pred = slope * lx[i] + b;
        RSS += (ly[i] - pred) ** 2;
      }
      const df = Math.max(1, n - 2);
      const s2 = RSS / df;
      const SE = Math.sqrt(Sxx ? s2 / Sxx : 0);

      // 95% CI (use conservative t if very small df)
      const tcrit = (df === 2) ? 4.303 : (df > 20 ? 1.96 : 2.776);
      const lo = slope - tcrit * SE;
      const hi = slope + tcrit * SE;

      const TSS = ly.reduce((acc, y) => acc + (y - ym) ** 2, 0);
      const R2 = TSS > 0 ? 1 - RSS / TSS : 0;

      return { slope, lo, hi, R2 };
    }

    // --- App wiring ----------------------------------------------------------

    const COLORS = {
      sgd: getComputedStyle(document.documentElement).getPropertyValue('--sgd').trim() || '#ef4444',
      adam: getComputedStyle(document.documentElement).getPropertyValue('--adam').trim() || '#14b8a6',
      symp: getComputedStyle(document.documentElement).getPropertyValue('--symp').trim() || '#84cc16'
    };

    const sgdCanvas = $('sgdCanvas');
    const adamCanvas = $('adamCanvas');
    const sympCanvas = $('sympCanvas');
    const sgdCtx = sgdCanvas.getContext('2d');
    const adamCtx = adamCanvas.getContext('2d');
    const sympCtx = sympCanvas.getContext('2d');

    let animationId = null;
    let optimizers = {};
    const dtOut = $('stepValue'), noiseOut = $('noiseValue');

    function readParams() {
      const dt = parseFloat(dtOut.textContent);
      const noise = parseFloat(noiseOut.textContent);
      return { dt, noise };
    }

    function resizeAll() {
      const { width: ws, height: hs } = sizeCanvasForDisplay(sgdCanvas);
      const { width: wa, height: ha } = sizeCanvasForDisplay(adamCanvas);
      const { width: wq, height: hq } = sizeCanvasForDisplay(sympCanvas);

      drawEnergyPlot(sgdCtx, optimizers.sgd?.energyHistory || [], COLORS.sgd, ws, hs);
      drawEnergyPlot(adamCtx, optimizers.adam?.energyHistory || [], COLORS.adam, wa, ha);
      drawEnergyPlot(sympCtx, optimizers.symp?.energyHistory || [], COLORS.symp, wq, hq);
    }

    function reset() {
      // Stop anim if running
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
        $('startBtn').textContent = '▶ Start';
        $('startBtn').setAttribute('aria-pressed', 'false');
      }
      optimizers = {
        sgd: new Optimizer('sgd'),        // live animation uses unseeded RNG
        adam: new Optimizer('adam'),
        symp: new Optimizer('symplectic')
      };
      resizeAll();
    }

    function animate() {
      const { dt, noise } = readParams();

      optimizers.sgd.update(dt, noise);
      optimizers.adam.update(dt, noise);
      optimizers.symp.update(dt, noise);

      const { width: ws, height: hs } = sizeCanvasForDisplay(sgdCanvas);
      const { width: wa, height: ha } = sizeCanvasForDisplay(adamCanvas);
      const { width: wq, height: hq } = sizeCanvasForDisplay(sympCanvas);

      drawEnergyPlot(sgdCtx, optimizers.sgd.energyHistory, COLORS.sgd, ws, hs);
      drawEnergyPlot(adamCtx, optimizers.adam.energyHistory, COLORS.adam, wa, ha);
      drawEnergyPlot(sympCtx, optimizers.symp.energyHistory, COLORS.symp, wq, hq);

      animationId = requestAnimationFrame(animate);
    }

    // --- Event handlers ------------------------------------------------------

    $('startBtn').addEventListener('click', () => {
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
        $('startBtn').textContent = '▶ Start';
        $('startBtn').setAttribute('aria-pressed', 'false');
      } else {
        animate();
        $('startBtn').textContent = '⏸ Pause';
        $('startBtn').setAttribute('aria-pressed', 'true');
      }
    });

    $('resetBtn').addEventListener('click', reset);

    $('sweepBtn').addEventListener('click', async () => {
      const btn = $('sweepBtn');
      btn.disabled = true;
      btn.textContent = '… Measuring';
      const status = $('measureStatus');
      status.textContent = 'Running 4-point sweep over canonical dt band…';
      status.setAttribute('aria-busy', 'true');

      await new Promise(r => setTimeout(r, 45)); // allow UI paint

      // Canonical band
      const dtBand = [0.0020, 0.0025, 0.0030, 0.0035];
      const noise = parseFloat(noiseOut.textContent);

      // Map display keys to internal method names
      const methodMap = { sgd: 'sgd', adam: 'adam', symp: 'symplectic' };
      const results = {};

      for (const key of Object.keys(methodMap)) {
        const method = methodMap[key];
        const drifts = [];
        for (const dt of dtBand) {
          const drift = measureDrift(method, dt, noise);
          drifts.push(Math.max(1e-12, drift));
        }
        results[key] = olsSlopeLog10(dtBand, drifts);
      }

      const fmt = (v) => (v >= 0 ? `+${v.toFixed(3)}` : v.toFixed(3));
      const rSGD = results.sgd, rAdam = results.adam, rSymp = results.symp;

      $('sgdSlope').textContent = fmt(rSGD.slope);
      $('sgdCI').textContent = `[${fmt(rSGD.lo)}, ${fmt(rSGD.hi)}]`;

      $('adamSlope').textContent = fmt(rAdam.slope);
      $('adamCI').textContent = `[${fmt(rAdam.lo)}, ${fmt(rAdam.hi)}]`;

      $('sympSlope').textContent = fmt(rSymp.slope);
      $('sympCI').textContent = `[${fmt(rSymp.lo)}, ${fmt(rSymp.hi)}]`;

      const okFit = rSymp.R2 >= 0.30;
      const isNegative = rSymp.slope < 0 && okFit;

      $('magicIndicator').classList.toggle('active', isNegative);
      $('sympCard').classList.toggle('negative', isNegative);

      if (isNegative) {
        status.textContent = `✨ Negative drift scaling confirmed for Symplectic: ${fmt(rSymp.slope)} (R² = ${rSymp.R2.toFixed(3)}).`;
      } else {
        status.textContent = okFit
          ? 'Measurement complete — no negative slope detected this run.'
          : 'Measurement complete — fit is weak; try a different σ.';
      }
      status.removeAttribute('aria-busy');

      btn.disabled = false;
      btn.textContent = '⟲ Measure Slopes';
    });

    // Sliders -> outputs
    $('stepSize').addEventListener('input', (e) => {
      const value = (e.target.valueAsNumber / 1000);
      dtOut.textContent = value.toFixed(3);
      e.target.setAttribute('aria-valuenow', dtOut.textContent);
    });
    $('noise').addEventListener('input', (e) => {
      const value = (e.target.valueAsNumber / 100);
      noiseOut.textContent = value.toFixed(2);
      e.target.setAttribute('aria-valuenow', noiseOut.textContent);
    });

    // Pause animation when tab is hidden (battery-friendly)
    document.addEventListener('visibilitychange', () => {
      if (document.hidden && animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
        $('startBtn').textContent = '▶ Start';
        $('startBtn').setAttribute('aria-pressed', 'false');
      }
    });

    // Responsive canvas
    window.addEventListener('resize', resizeAll, { passive: true });

    // Init
    reset();
  </script>
</body>
</html>